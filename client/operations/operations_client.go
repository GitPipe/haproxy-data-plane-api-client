// Code generated by go-swagger; DO NOT EDIT.

// Copyright 2019 HAProxy Technologies
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new operations API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for operations API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateACL adds a new ACL line

Adds a new ACL line of the specified type in the specified parent.
*/
func (a *Client) CreateACL(params *CreateACLParams, authInfo runtime.ClientAuthInfoWriter) (*CreateACLCreated, *CreateACLAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateACLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createAcl",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/acls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateACLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateACLCreated:
		return value, nil, nil
	case *CreateACLAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateBackend adds a backend

Adds a new backend to the configuration file.
*/
func (a *Client) CreateBackend(params *CreateBackendParams, authInfo runtime.ClientAuthInfoWriter) (*CreateBackendCreated, *CreateBackendAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateBackendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createBackend",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/backends",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateBackendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateBackendCreated:
		return value, nil, nil
	case *CreateBackendAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateBackendSwitchingRule adds a new backend switching rule

Adds a new Backend Switching Rule of the specified type in the specified frontend.
*/
func (a *Client) CreateBackendSwitchingRule(params *CreateBackendSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateBackendSwitchingRuleCreated, *CreateBackendSwitchingRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateBackendSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createBackendSwitchingRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/backend_switching_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateBackendSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateBackendSwitchingRuleCreated:
		return value, nil, nil
	case *CreateBackendSwitchingRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateBind adds a new bind

Adds a new bind in the specified frontend in the configuration file.
*/
func (a *Client) CreateBind(params *CreateBindParams, authInfo runtime.ClientAuthInfoWriter) (*CreateBindCreated, *CreateBindAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateBindParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createBind",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/binds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateBindReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateBindCreated:
		return value, nil, nil
	case *CreateBindAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateFilter adds a new filter

Adds a new Filter of the specified type in the specified parent.
*/
func (a *Client) CreateFilter(params *CreateFilterParams, authInfo runtime.ClientAuthInfoWriter) (*CreateFilterCreated, *CreateFilterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createFilter",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/filters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateFilterCreated:
		return value, nil, nil
	case *CreateFilterAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateFrontend adds a frontend

Adds a new frontend to the configuration file.
*/
func (a *Client) CreateFrontend(params *CreateFrontendParams, authInfo runtime.ClientAuthInfoWriter) (*CreateFrontendCreated, *CreateFrontendAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateFrontendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createFrontend",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/frontends",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateFrontendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateFrontendCreated:
		return value, nil, nil
	case *CreateFrontendAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateHTTPRequestRule adds a new HTTP request rule

Adds a new HTTP Request Rule of the specified type in the specified parent.
*/
func (a *Client) CreateHTTPRequestRule(params *CreateHTTPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateHTTPRequestRuleCreated, *CreateHTTPRequestRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateHTTPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createHTTPRequestRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/http_request_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateHTTPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateHTTPRequestRuleCreated:
		return value, nil, nil
	case *CreateHTTPRequestRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateHTTPResponseRule adds a new HTTP response rule

Adds a new HTTP Response Rule of the specified type in the specified parent.
*/
func (a *Client) CreateHTTPResponseRule(params *CreateHTTPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateHTTPResponseRuleCreated, *CreateHTTPResponseRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateHTTPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createHTTPResponseRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/http_response_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateHTTPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateHTTPResponseRuleCreated:
		return value, nil, nil
	case *CreateHTTPResponseRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateLogTarget adds a new log target

Adds a new Log Target of the specified type in the specified parent.
*/
func (a *Client) CreateLogTarget(params *CreateLogTargetParams, authInfo runtime.ClientAuthInfoWriter) (*CreateLogTargetCreated, *CreateLogTargetAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateLogTargetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createLogTarget",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/log_targets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateLogTargetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateLogTargetCreated:
		return value, nil, nil
	case *CreateLogTargetAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateNameserver adds a nameserver

Adds a new nameserver to the resolvers section.
*/
func (a *Client) CreateNameserver(params *CreateNameserverParams, authInfo runtime.ClientAuthInfoWriter) (*CreateNameserverCreated, *CreateNameserverAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateNameserverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createNameserver",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/nameservers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateNameserverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateNameserverCreated:
		return value, nil, nil
	case *CreateNameserverAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreatePeer adds a peer

Adds a new peer to the configuration file.
*/
func (a *Client) CreatePeer(params *CreatePeerParams, authInfo runtime.ClientAuthInfoWriter) (*CreatePeerCreated, *CreatePeerAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePeerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createPeer",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/peer_section",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreatePeerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreatePeerCreated:
		return value, nil, nil
	case *CreatePeerAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreatePeerEntry adds a new peer entry

Adds a new peer entry in the specified peer section in the configuration file.
*/
func (a *Client) CreatePeerEntry(params *CreatePeerEntryParams, authInfo runtime.ClientAuthInfoWriter) (*CreatePeerEntryCreated, *CreatePeerEntryAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePeerEntryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createPeerEntry",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/peer_entries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreatePeerEntryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreatePeerEntryCreated:
		return value, nil, nil
	case *CreatePeerEntryAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateResolver adds a resolver

Adds a new resolver section to the configuration file.
*/
func (a *Client) CreateResolver(params *CreateResolverParams, authInfo runtime.ClientAuthInfoWriter) (*CreateResolverCreated, *CreateResolverAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateResolverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createResolver",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/resolvers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateResolverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateResolverCreated:
		return value, nil, nil
	case *CreateResolverAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateServer adds a new server

Adds a new server in the specified backend in the configuration file.
*/
func (a *Client) CreateServer(params *CreateServerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateServerCreated, *CreateServerAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createServer",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/servers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateServerCreated:
		return value, nil, nil
	case *CreateServerAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateServerSwitchingRule adds a new server switching rule

Adds a new Server Switching Rule of the specified type in the specified backend.
*/
func (a *Client) CreateServerSwitchingRule(params *CreateServerSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateServerSwitchingRuleCreated, *CreateServerSwitchingRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateServerSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createServerSwitchingRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/server_switching_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateServerSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateServerSwitchingRuleCreated:
		return value, nil, nil
	case *CreateServerSwitchingRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateStickRule adds a new stick rule

Adds a new Stick Rule of the specified type in the specified backend.
*/
func (a *Client) CreateStickRule(params *CreateStickRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateStickRuleCreated, *CreateStickRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateStickRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createStickRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/stick_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateStickRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateStickRuleCreated:
		return value, nil, nil
	case *CreateStickRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateTCPRequestRule adds a new TCP request rule

Adds a new TCP Request Rule of the specified type in the specified parent.
*/
func (a *Client) CreateTCPRequestRule(params *CreateTCPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateTCPRequestRuleCreated, *CreateTCPRequestRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateTCPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createTCPRequestRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/tcp_request_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateTCPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateTCPRequestRuleCreated:
		return value, nil, nil
	case *CreateTCPRequestRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
CreateTCPResponseRule adds a new TCP response rule

Adds a new TCP Response Rule of the specified type in the specified backend.
*/
func (a *Client) CreateTCPResponseRule(params *CreateTCPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*CreateTCPResponseRuleCreated, *CreateTCPResponseRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateTCPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createTCPResponseRule",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/tcp_response_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CreateTCPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *CreateTCPResponseRuleCreated:
		return value, nil, nil
	case *CreateTCPResponseRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteACL deletes a ACL line

Deletes a ACL line configuration by it's index from the specified parent.
*/
func (a *Client) DeleteACL(params *DeleteACLParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteACLAccepted, *DeleteACLNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteACLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteAcl",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/acls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteACLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteACLAccepted:
		return value, nil, nil
	case *DeleteACLNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteBackend deletes a backend

Deletes a frontend from the configuration by it's name.
*/
func (a *Client) DeleteBackend(params *DeleteBackendParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteBackendAccepted, *DeleteBackendNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteBackendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteBackend",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/backends/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteBackendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteBackendAccepted:
		return value, nil, nil
	case *DeleteBackendNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteBackendSwitchingRule deletes a backend switching rule

Deletes a Backend Switching Rule configuration by it's index from the specified frontend.
*/
func (a *Client) DeleteBackendSwitchingRule(params *DeleteBackendSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteBackendSwitchingRuleAccepted, *DeleteBackendSwitchingRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteBackendSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteBackendSwitchingRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/backend_switching_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteBackendSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteBackendSwitchingRuleAccepted:
		return value, nil, nil
	case *DeleteBackendSwitchingRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteBind deletes a bind

Deletes a bind configuration by it's name in the specified frontend.
*/
func (a *Client) DeleteBind(params *DeleteBindParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteBindAccepted, *DeleteBindNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteBindParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteBind",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/binds/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteBindReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteBindAccepted:
		return value, nil, nil
	case *DeleteBindNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteFilter deletes a filter

Deletes a Filter configuration by it's index from the specified parent.
*/
func (a *Client) DeleteFilter(params *DeleteFilterParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteFilterAccepted, *DeleteFilterNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteFilter",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/filters/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteFilterAccepted:
		return value, nil, nil
	case *DeleteFilterNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteFrontend deletes a frontend

Deletes a frontend from the configuration by it's name.
*/
func (a *Client) DeleteFrontend(params *DeleteFrontendParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteFrontendAccepted, *DeleteFrontendNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteFrontendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteFrontend",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/frontends/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteFrontendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteFrontendAccepted:
		return value, nil, nil
	case *DeleteFrontendNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteHTTPRequestRule deletes a HTTP request rule

Deletes a HTTP Request Rule configuration by it's index from the specified parent.
*/
func (a *Client) DeleteHTTPRequestRule(params *DeleteHTTPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteHTTPRequestRuleAccepted, *DeleteHTTPRequestRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteHTTPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteHTTPRequestRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/http_request_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteHTTPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteHTTPRequestRuleAccepted:
		return value, nil, nil
	case *DeleteHTTPRequestRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteHTTPResponseRule deletes a HTTP response rule

Deletes a HTTP Response Rule configuration by it's index from the specified parent.
*/
func (a *Client) DeleteHTTPResponseRule(params *DeleteHTTPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteHTTPResponseRuleAccepted, *DeleteHTTPResponseRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteHTTPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteHTTPResponseRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/http_response_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteHTTPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteHTTPResponseRuleAccepted:
		return value, nil, nil
	case *DeleteHTTPResponseRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteLogTarget deletes a log target

Deletes a Log Target configuration by it's index from the specified parent.
*/
func (a *Client) DeleteLogTarget(params *DeleteLogTargetParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteLogTargetAccepted, *DeleteLogTargetNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteLogTargetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteLogTarget",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/log_targets/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteLogTargetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteLogTargetAccepted:
		return value, nil, nil
	case *DeleteLogTargetNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteNameserver deletes a nameserver

Deletes a nameserver from the resolvers section by it's name.
*/
func (a *Client) DeleteNameserver(params *DeleteNameserverParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteNameserverAccepted, *DeleteNameserverNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteNameserverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteNameserver",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/nameservers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteNameserverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteNameserverAccepted:
		return value, nil, nil
	case *DeleteNameserverNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeletePeer deletes a peer

Deletes a peer from the configuration by it's name.
*/
func (a *Client) DeletePeer(params *DeletePeerParams, authInfo runtime.ClientAuthInfoWriter) (*DeletePeerAccepted, *DeletePeerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePeerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deletePeer",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/peer_section/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeletePeerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeletePeerAccepted:
		return value, nil, nil
	case *DeletePeerNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeletePeerEntry deletes a peer entry

Deletes a peer entry configuration by it's name in the specified peer section.
*/
func (a *Client) DeletePeerEntry(params *DeletePeerEntryParams, authInfo runtime.ClientAuthInfoWriter) (*DeletePeerEntryAccepted, *DeletePeerEntryNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePeerEntryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deletePeerEntry",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/peer_entries/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeletePeerEntryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeletePeerEntryAccepted:
		return value, nil, nil
	case *DeletePeerEntryNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteResolver deletes a resolver

Deletes a resolver from the configuration by it's name.
*/
func (a *Client) DeleteResolver(params *DeleteResolverParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteResolverAccepted, *DeleteResolverNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteResolverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteResolver",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/resolvers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteResolverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteResolverAccepted:
		return value, nil, nil
	case *DeleteResolverNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteServer deletes a server

Deletes a server configuration by it's name in the specified backend.
*/
func (a *Client) DeleteServer(params *DeleteServerParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteServerAccepted, *DeleteServerNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteServer",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/servers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteServerAccepted:
		return value, nil, nil
	case *DeleteServerNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteServerSwitchingRule deletes a server switching rule

Deletes a Server Switching Rule configuration by it's index from the specified backend.
*/
func (a *Client) DeleteServerSwitchingRule(params *DeleteServerSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteServerSwitchingRuleAccepted, *DeleteServerSwitchingRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteServerSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteServerSwitchingRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/server_switching_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteServerSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteServerSwitchingRuleAccepted:
		return value, nil, nil
	case *DeleteServerSwitchingRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteStickRule deletes a stick rule

Deletes a Stick Rule configuration by it's index from the specified backend.
*/
func (a *Client) DeleteStickRule(params *DeleteStickRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteStickRuleAccepted, *DeleteStickRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteStickRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteStickRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/stick_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteStickRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteStickRuleAccepted:
		return value, nil, nil
	case *DeleteStickRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteTCPRequestRule deletes a TCP request rule

Deletes a TCP Request Rule configuration by it's index from the specified parent.
*/
func (a *Client) DeleteTCPRequestRule(params *DeleteTCPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTCPRequestRuleAccepted, *DeleteTCPRequestRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTCPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTCPRequestRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/tcp_request_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteTCPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteTCPRequestRuleAccepted:
		return value, nil, nil
	case *DeleteTCPRequestRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
DeleteTCPResponseRule deletes a TCP response rule

Deletes a TCP Response Rule configuration by it's index from the specified backend.
*/
func (a *Client) DeleteTCPResponseRule(params *DeleteTCPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteTCPResponseRuleAccepted, *DeleteTCPResponseRuleNoContent, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTCPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTCPResponseRule",
		Method:             "DELETE",
		PathPattern:        "/services/haproxy/configuration/tcp_response_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteTCPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *DeleteTCPResponseRuleAccepted:
		return value, nil, nil
	case *DeleteTCPResponseRuleNoContent:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
GetACL returns one ACL line

Returns one ACL line configuration by it's index in the specified parent.
*/
func (a *Client) GetACL(params *GetACLParams, authInfo runtime.ClientAuthInfoWriter) (*GetACLOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetACLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAcl",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/acls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetACLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetACLOK), nil

}

/*
GetAcls returns an array of all ACL lines

Returns all ACL lines that are configured in specified parent.
*/
func (a *Client) GetAcls(params *GetAclsParams, authInfo runtime.ClientAuthInfoWriter) (*GetAclsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAclsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAcls",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/acls",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetAclsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAclsOK), nil

}

/*
GetBackend returns a backend

Returns one backend configuration by it's name.
*/
func (a *Client) GetBackend(params *GetBackendParams, authInfo runtime.ClientAuthInfoWriter) (*GetBackendOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBackendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBackend",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/backends/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBackendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBackendOK), nil

}

/*
GetBackendSwitchingRule returns one backend switching rule

Returns one Backend Switching Rule configuration by it's index in the specified frontend.
*/
func (a *Client) GetBackendSwitchingRule(params *GetBackendSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetBackendSwitchingRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBackendSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBackendSwitchingRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/backend_switching_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBackendSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBackendSwitchingRuleOK), nil

}

/*
GetBackendSwitchingRules returns an array of all backend switching rules

Returns all Backend Switching Rules that are configured in specified frontend.
*/
func (a *Client) GetBackendSwitchingRules(params *GetBackendSwitchingRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetBackendSwitchingRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBackendSwitchingRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBackendSwitchingRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/backend_switching_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBackendSwitchingRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBackendSwitchingRulesOK), nil

}

/*
GetBackends returns an array of backends

Returns an array of all configured backends.
*/
func (a *Client) GetBackends(params *GetBackendsParams, authInfo runtime.ClientAuthInfoWriter) (*GetBackendsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBackendsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBackends",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/backends",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBackendsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBackendsOK), nil

}

/*
GetBind returns one bind

Returns one bind configuration by it's name in the specified frontend.
*/
func (a *Client) GetBind(params *GetBindParams, authInfo runtime.ClientAuthInfoWriter) (*GetBindOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBindParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBind",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/binds/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBindReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBindOK), nil

}

/*
GetBinds returns an array of binds

Returns an array of all binds that are configured in specified frontend.
*/
func (a *Client) GetBinds(params *GetBindsParams, authInfo runtime.ClientAuthInfoWriter) (*GetBindsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetBindsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getBinds",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/binds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetBindsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetBindsOK), nil

}

/*
GetDefaults returns defaults part of configuration

Returns defaults part of configuration.
*/
func (a *Client) GetDefaults(params *GetDefaultsParams, authInfo runtime.ClientAuthInfoWriter) (*GetDefaultsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDefaultsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDefaults",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/defaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDefaultsOK), nil

}

/*
GetFilter returns one filter

Returns one Filter configuration by it's index in the specified parent.
*/
func (a *Client) GetFilter(params *GetFilterParams, authInfo runtime.ClientAuthInfoWriter) (*GetFilterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFilter",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/filters/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFilterOK), nil

}

/*
GetFilters returns an array of all filters

Returns all Filters that are configured in specified parent.
*/
func (a *Client) GetFilters(params *GetFiltersParams, authInfo runtime.ClientAuthInfoWriter) (*GetFiltersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFiltersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFilters",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/filters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetFiltersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFiltersOK), nil

}

/*
GetFrontend returns a frontend

Returns one frontend configuration by it's name.
*/
func (a *Client) GetFrontend(params *GetFrontendParams, authInfo runtime.ClientAuthInfoWriter) (*GetFrontendOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFrontendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFrontend",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/frontends/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetFrontendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFrontendOK), nil

}

/*
GetFrontends returns an array of frontends

Returns an array of all configured frontends.
*/
func (a *Client) GetFrontends(params *GetFrontendsParams, authInfo runtime.ClientAuthInfoWriter) (*GetFrontendsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFrontendsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFrontends",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/frontends",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetFrontendsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFrontendsOK), nil

}

/*
GetGlobal returns a global part of configuration

Returns global part of configuration.
*/
func (a *Client) GetGlobal(params *GetGlobalParams, authInfo runtime.ClientAuthInfoWriter) (*GetGlobalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetGlobalParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getGlobal",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/global",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetGlobalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetGlobalOK), nil

}

/*
GetHAProxyConfiguration returns h a proxy configuration

Returns HAProxy configuration file in plain text
*/
func (a *Client) GetHAProxyConfiguration(params *GetHAProxyConfigurationParams, authInfo runtime.ClientAuthInfoWriter) (*GetHAProxyConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHAProxyConfigurationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHAProxyConfiguration",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/raw",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetHAProxyConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHAProxyConfigurationOK), nil

}

/*
GetHTTPRequestRule returns one HTTP request rule

Returns one HTTP Request Rule configuration by it's index in the specified parent.
*/
func (a *Client) GetHTTPRequestRule(params *GetHTTPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetHTTPRequestRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHTTPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHTTPRequestRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/http_request_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetHTTPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHTTPRequestRuleOK), nil

}

/*
GetHTTPRequestRules returns an array of all HTTP request rules

Returns all HTTP Request Rules that are configured in specified parent.
*/
func (a *Client) GetHTTPRequestRules(params *GetHTTPRequestRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetHTTPRequestRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHTTPRequestRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHTTPRequestRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/http_request_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetHTTPRequestRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHTTPRequestRulesOK), nil

}

/*
GetHTTPResponseRule returns one HTTP response rule

Returns one HTTP Response Rule configuration by it's index in the specified parent.
*/
func (a *Client) GetHTTPResponseRule(params *GetHTTPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetHTTPResponseRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHTTPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHTTPResponseRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/http_response_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetHTTPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHTTPResponseRuleOK), nil

}

/*
GetHTTPResponseRules returns an array of all HTTP response rules

Returns all HTTP Response Rules that are configured in specified parent.
*/
func (a *Client) GetHTTPResponseRules(params *GetHTTPResponseRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetHTTPResponseRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetHTTPResponseRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getHTTPResponseRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/http_response_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetHTTPResponseRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetHTTPResponseRulesOK), nil

}

/*
GetLogTarget returns one log target

Returns one Log Target configuration by it's index in the specified parent.
*/
func (a *Client) GetLogTarget(params *GetLogTargetParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogTargetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogTargetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLogTarget",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/log_targets/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLogTargetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogTargetOK), nil

}

/*
GetLogTargets returns an array of all log targets

Returns all Log Targets that are configured in specified parent.
*/
func (a *Client) GetLogTargets(params *GetLogTargetsParams, authInfo runtime.ClientAuthInfoWriter) (*GetLogTargetsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetLogTargetsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getLogTargets",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/log_targets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetLogTargetsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetLogTargetsOK), nil

}

/*
GetNameserver returns a nameserver

Returns one nameserver configuration by it's name.
*/
func (a *Client) GetNameserver(params *GetNameserverParams, authInfo runtime.ClientAuthInfoWriter) (*GetNameserverOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNameserverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getNameserver",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/nameservers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetNameserverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNameserverOK), nil

}

/*
GetNameservers returns an array of nameservers

Returns an array of all configured nameservers.
*/
func (a *Client) GetNameservers(params *GetNameserversParams, authInfo runtime.ClientAuthInfoWriter) (*GetNameserversOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetNameserversParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getNameservers",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/nameservers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetNameserversReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetNameserversOK), nil

}

/*
GetPeerEntries returns an array of peer entries

Returns an array of all peer_entries that are configured in specified peer section.
*/
func (a *Client) GetPeerEntries(params *GetPeerEntriesParams, authInfo runtime.ClientAuthInfoWriter) (*GetPeerEntriesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPeerEntriesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPeerEntries",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/peer_entries",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPeerEntriesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPeerEntriesOK), nil

}

/*
GetPeerEntry returns one peer entry

Returns one peer_entry configuration by it's name in the specified peer section.
*/
func (a *Client) GetPeerEntry(params *GetPeerEntryParams, authInfo runtime.ClientAuthInfoWriter) (*GetPeerEntryOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPeerEntryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPeerEntry",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/peer_entries/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPeerEntryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPeerEntryOK), nil

}

/*
GetPeerSection returns a peer

Returns one peer configuration by it's name.
*/
func (a *Client) GetPeerSection(params *GetPeerSectionParams, authInfo runtime.ClientAuthInfoWriter) (*GetPeerSectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPeerSectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPeerSection",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/peer_section/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPeerSectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPeerSectionOK), nil

}

/*
GetPeerSections returns an array of peer section

Returns an array of all configured peer_section.
*/
func (a *Client) GetPeerSections(params *GetPeerSectionsParams, authInfo runtime.ClientAuthInfoWriter) (*GetPeerSectionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPeerSectionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPeerSections",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/peer_section",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetPeerSectionsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPeerSectionsOK), nil

}

/*
GetResolver returns a resolver

Returns one resolver section configuration by it's name.
*/
func (a *Client) GetResolver(params *GetResolverParams, authInfo runtime.ClientAuthInfoWriter) (*GetResolverOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResolverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getResolver",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/resolvers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetResolverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetResolverOK), nil

}

/*
GetResolvers returns an array of resolvers

Returns an array of all configured resolvers.
*/
func (a *Client) GetResolvers(params *GetResolversParams, authInfo runtime.ClientAuthInfoWriter) (*GetResolversOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetResolversParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getResolvers",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/resolvers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetResolversReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetResolversOK), nil

}

/*
GetRuntimeServer returns one server runtime settings

Returns one server runtime settings by it's name in the specified backend.
*/
func (a *Client) GetRuntimeServer(params *GetRuntimeServerParams, authInfo runtime.ClientAuthInfoWriter) (*GetRuntimeServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRuntimeServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRuntimeServer",
		Method:             "GET",
		PathPattern:        "/services/haproxy/runtime/servers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRuntimeServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRuntimeServerOK), nil

}

/*
GetRuntimeServers returns an array of runtime servers setings

Returns an array of all servers' runtime settings.
*/
func (a *Client) GetRuntimeServers(params *GetRuntimeServersParams, authInfo runtime.ClientAuthInfoWriter) (*GetRuntimeServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRuntimeServersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRuntimeServers",
		Method:             "GET",
		PathPattern:        "/services/haproxy/runtime/servers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetRuntimeServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRuntimeServersOK), nil

}

/*
GetServer returns one server

Returns one server configuration by it's name in the specified backend.
*/
func (a *Client) GetServer(params *GetServerParams, authInfo runtime.ClientAuthInfoWriter) (*GetServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getServer",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/servers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetServerOK), nil

}

/*
GetServerSwitchingRule returns one server switching rule

Returns one Server Switching Rule configuration by it's index in the specified backend.
*/
func (a *Client) GetServerSwitchingRule(params *GetServerSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetServerSwitchingRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServerSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getServerSwitchingRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/server_switching_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetServerSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetServerSwitchingRuleOK), nil

}

/*
GetServerSwitchingRules returns an array of all server switching rules

Returns all Backend Switching Rules that are configured in specified backend.
*/
func (a *Client) GetServerSwitchingRules(params *GetServerSwitchingRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetServerSwitchingRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServerSwitchingRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getServerSwitchingRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/server_switching_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetServerSwitchingRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetServerSwitchingRulesOK), nil

}

/*
GetServers returns an array of servers

Returns an array of all servers that are configured in specified backend.
*/
func (a *Client) GetServers(params *GetServersParams, authInfo runtime.ClientAuthInfoWriter) (*GetServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetServersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getServers",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/servers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetServersOK), nil

}

/*
GetStickRule returns one stick rule

Returns one Stick Rule configuration by it's index in the specified backend.
*/
func (a *Client) GetStickRule(params *GetStickRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetStickRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetStickRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getStickRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/stick_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetStickRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetStickRuleOK), nil

}

/*
GetStickRules returns an array of all stick rules

Returns all Stick Rules that are configured in specified backend.
*/
func (a *Client) GetStickRules(params *GetStickRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetStickRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetStickRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getStickRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/stick_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetStickRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetStickRulesOK), nil

}

/*
GetTCPRequestRule returns one TCP request rule

Returns one TCP Request Rule configuration by it's index in the specified parent.
*/
func (a *Client) GetTCPRequestRule(params *GetTCPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetTCPRequestRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTCPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTCPRequestRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/tcp_request_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTCPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTCPRequestRuleOK), nil

}

/*
GetTCPRequestRules returns an array of all TCP request rules

Returns all TCP Request Rules that are configured in specified parent and parent type.
*/
func (a *Client) GetTCPRequestRules(params *GetTCPRequestRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetTCPRequestRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTCPRequestRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTCPRequestRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/tcp_request_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTCPRequestRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTCPRequestRulesOK), nil

}

/*
GetTCPResponseRule returns one TCP response rule

Returns one TCP Response Rule configuration by it's index in the specified backend.
*/
func (a *Client) GetTCPResponseRule(params *GetTCPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*GetTCPResponseRuleOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTCPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTCPResponseRule",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/tcp_response_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTCPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTCPResponseRuleOK), nil

}

/*
GetTCPResponseRules returns an array of all TCP response rules

Returns all TCP Response Rules that are configured in specified backend.
*/
func (a *Client) GetTCPResponseRules(params *GetTCPResponseRulesParams, authInfo runtime.ClientAuthInfoWriter) (*GetTCPResponseRulesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTCPResponseRulesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTCPResponseRules",
		Method:             "GET",
		PathPattern:        "/services/haproxy/configuration/tcp_response_rules",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &GetTCPResponseRulesReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTCPResponseRulesOK), nil

}

/*
PostHAProxyConfiguration pushes new haproxy configuration

Push a new haproxy configuration file in plain text
*/
func (a *Client) PostHAProxyConfiguration(params *PostHAProxyConfigurationParams, authInfo runtime.ClientAuthInfoWriter) (*PostHAProxyConfigurationCreated, *PostHAProxyConfigurationAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostHAProxyConfigurationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postHAProxyConfiguration",
		Method:             "POST",
		PathPattern:        "/services/haproxy/configuration/raw",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"text/plain"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PostHAProxyConfigurationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *PostHAProxyConfigurationCreated:
		return value, nil, nil
	case *PostHAProxyConfigurationAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceACL replaces a ACL line

Replaces a ACL line configuration by it's index in the specified parent.
*/
func (a *Client) ReplaceACL(params *ReplaceACLParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceACLOK, *ReplaceACLAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceACLParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceAcl",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/acls/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceACLReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceACLOK:
		return value, nil, nil
	case *ReplaceACLAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceBackend replaces a backend

Replaces a backend configuration by it's name.
*/
func (a *Client) ReplaceBackend(params *ReplaceBackendParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceBackendOK, *ReplaceBackendAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceBackendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceBackend",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/backends/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceBackendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceBackendOK:
		return value, nil, nil
	case *ReplaceBackendAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceBackendSwitchingRule replaces a backend switching rule

Replaces a Backend Switching Rule configuration by it's index in the specified frontend.
*/
func (a *Client) ReplaceBackendSwitchingRule(params *ReplaceBackendSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceBackendSwitchingRuleOK, *ReplaceBackendSwitchingRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceBackendSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceBackendSwitchingRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/backend_switching_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceBackendSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceBackendSwitchingRuleOK:
		return value, nil, nil
	case *ReplaceBackendSwitchingRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceBind replaces a bind

Replaces a bind configuration by it's name in the specified frontend.
*/
func (a *Client) ReplaceBind(params *ReplaceBindParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceBindOK, *ReplaceBindAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceBindParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceBind",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/binds/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceBindReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceBindOK:
		return value, nil, nil
	case *ReplaceBindAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceDefaults replaces defaults

Replace defaults part of config
*/
func (a *Client) ReplaceDefaults(params *ReplaceDefaultsParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceDefaultsOK, *ReplaceDefaultsAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceDefaultsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceDefaults",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/defaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceDefaultsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceDefaultsOK:
		return value, nil, nil
	case *ReplaceDefaultsAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceFilter replaces a filter

Replaces a Filter configuration by it's index in the specified parent.
*/
func (a *Client) ReplaceFilter(params *ReplaceFilterParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceFilterOK, *ReplaceFilterAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceFilter",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/filters/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceFilterOK:
		return value, nil, nil
	case *ReplaceFilterAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceFrontend replaces a frontend

Replaces a frontend configuration by it's name.
*/
func (a *Client) ReplaceFrontend(params *ReplaceFrontendParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceFrontendOK, *ReplaceFrontendAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceFrontendParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceFrontend",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/frontends/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceFrontendReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceFrontendOK:
		return value, nil, nil
	case *ReplaceFrontendAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceGlobal replaces global

Replace global part of config
*/
func (a *Client) ReplaceGlobal(params *ReplaceGlobalParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceGlobalOK, *ReplaceGlobalAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceGlobalParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceGlobal",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/global",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceGlobalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceGlobalOK:
		return value, nil, nil
	case *ReplaceGlobalAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceHTTPRequestRule replaces a HTTP request rule

Replaces a HTTP Request Rule configuration by it's index in the specified parent.
*/
func (a *Client) ReplaceHTTPRequestRule(params *ReplaceHTTPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceHTTPRequestRuleOK, *ReplaceHTTPRequestRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceHTTPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceHTTPRequestRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/http_request_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceHTTPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceHTTPRequestRuleOK:
		return value, nil, nil
	case *ReplaceHTTPRequestRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceHTTPResponseRule replaces a HTTP response rule

Replaces a HTTP Response Rule configuration by it's index in the specified parent.
*/
func (a *Client) ReplaceHTTPResponseRule(params *ReplaceHTTPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceHTTPResponseRuleOK, *ReplaceHTTPResponseRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceHTTPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceHTTPResponseRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/http_response_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceHTTPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceHTTPResponseRuleOK:
		return value, nil, nil
	case *ReplaceHTTPResponseRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceLogTarget replaces a log target

Replaces a Log Target configuration by it's index in the specified parent.
*/
func (a *Client) ReplaceLogTarget(params *ReplaceLogTargetParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceLogTargetOK, *ReplaceLogTargetAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceLogTargetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceLogTarget",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/log_targets/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceLogTargetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceLogTargetOK:
		return value, nil, nil
	case *ReplaceLogTargetAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceNameserver replaces a nameserver

Replaces a nameserver configuration by it's name.
*/
func (a *Client) ReplaceNameserver(params *ReplaceNameserverParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceNameserverOK, *ReplaceNameserverAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceNameserverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceNameserver",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/nameservers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceNameserverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceNameserverOK:
		return value, nil, nil
	case *ReplaceNameserverAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplacePeerEntry replaces a peer entry

Replaces a peer entry configuration by it's name in the specified peer section.
*/
func (a *Client) ReplacePeerEntry(params *ReplacePeerEntryParams, authInfo runtime.ClientAuthInfoWriter) (*ReplacePeerEntryOK, *ReplacePeerEntryAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplacePeerEntryParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replacePeerEntry",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/peer_entries/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplacePeerEntryReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplacePeerEntryOK:
		return value, nil, nil
	case *ReplacePeerEntryAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceResolver replaces a resolver

Replaces a resolver configuration by it's name.
*/
func (a *Client) ReplaceResolver(params *ReplaceResolverParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceResolverOK, *ReplaceResolverAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceResolverParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceResolver",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/resolvers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceResolverReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceResolverOK:
		return value, nil, nil
	case *ReplaceResolverAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceRuntimeServer replaces server transient settings

Replaces a server transient settings by it's name in the specified backend.
*/
func (a *Client) ReplaceRuntimeServer(params *ReplaceRuntimeServerParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceRuntimeServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceRuntimeServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceRuntimeServer",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/runtime/servers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceRuntimeServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ReplaceRuntimeServerOK), nil

}

/*
ReplaceServer replaces a server

Replaces a server configuration by it's name in the specified backend.
*/
func (a *Client) ReplaceServer(params *ReplaceServerParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceServerOK, *ReplaceServerAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceServer",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/servers/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceServerOK:
		return value, nil, nil
	case *ReplaceServerAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceServerSwitchingRule replaces a server switching rule

Replaces a Server Switching Rule configuration by it's index in the specified backend.
*/
func (a *Client) ReplaceServerSwitchingRule(params *ReplaceServerSwitchingRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceServerSwitchingRuleOK, *ReplaceServerSwitchingRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceServerSwitchingRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceServerSwitchingRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/server_switching_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceServerSwitchingRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceServerSwitchingRuleOK:
		return value, nil, nil
	case *ReplaceServerSwitchingRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceStickRule replaces a stick rule

Replaces a Stick Rule configuration by it's index in the specified backend.
*/
func (a *Client) ReplaceStickRule(params *ReplaceStickRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceStickRuleOK, *ReplaceStickRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceStickRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceStickRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/stick_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceStickRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceStickRuleOK:
		return value, nil, nil
	case *ReplaceStickRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceTCPRequestRule replaces a TCP request rule

Replaces a TCP Request Rule configuration by it's index in the specified parent.
*/
func (a *Client) ReplaceTCPRequestRule(params *ReplaceTCPRequestRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceTCPRequestRuleOK, *ReplaceTCPRequestRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceTCPRequestRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceTCPRequestRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/tcp_request_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceTCPRequestRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceTCPRequestRuleOK:
		return value, nil, nil
	case *ReplaceTCPRequestRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

/*
ReplaceTCPResponseRule replaces a TCP response rule

Replaces a TCP Response Rule configuration by it's Index in the specified backend.
*/
func (a *Client) ReplaceTCPResponseRule(params *ReplaceTCPResponseRuleParams, authInfo runtime.ClientAuthInfoWriter) (*ReplaceTCPResponseRuleOK, *ReplaceTCPResponseRuleAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReplaceTCPResponseRuleParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "replaceTCPResponseRule",
		Method:             "PUT",
		PathPattern:        "/services/haproxy/configuration/tcp_response_rules/{index}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ReplaceTCPResponseRuleReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, nil, err
	}
	switch value := result.(type) {
	case *ReplaceTCPResponseRuleOK:
		return value, nil, nil
	case *ReplaceTCPResponseRuleAccepted:
		return nil, value, nil
	}
	return nil, nil, nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
